package zm.unza.counseling.config.ratelimit;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.BucketConfiguration;
import io.github.bucket4j.Refill;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;

import java.time.Duration;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Enterprise-grade rate limiting configuration
 * Provides configurable rate limiting for API endpoints
 */
@Configuration
@RequiredArgsConstructor
public class RateLimitConfig {

    private final RedisTemplate<String, Object> redisTemplate;
    private final ConcurrentMap<String, Bucket> cache = new ConcurrentHashMap<>();

    /**
     * Configuration for different rate limit tiers
     */
    public enum RateLimitTier {
        PUBLIC(100, Duration.ofMinutes(1)),           // 100 requests per minute
        AUTHENTICATED(1000, Duration.ofMinutes(1)),   // 1000 requests per minute
        ADMIN(5000, Duration.ofMinutes(1)),           // 5000 requests per minute
        CRITICAL(10, Duration.ofMinutes(1)),          // 10 requests per minute (login attempts)
        BULK(50, Duration.ofMinutes(1));              // 50 requests per minute (bulk operations)

        private final long capacity;
        private final Duration refillDuration;

        RateLimitTier(long capacity, Duration refillDuration) {
            this.capacity = capacity;
            this.refillDuration = refillDuration;
        }

        public long getCapacity() {
            return capacity;
        }

        public Duration getRefillDuration() {
            return refillDuration;
        }
    }

    /**
     * Create rate limiting bucket for a key
     */
    public Bucket createNewBucket(String key, RateLimitTier tier) {
        Bandwidth limit = Bandwidth.classic(tier.getCapacity(), Refill.intervally(tier.getCapacity(), tier.getRefillDuration()));
        BucketConfiguration configuration = BucketConfiguration.builder()
                .addLimit(limit)
                .build();
        
        Bucket bucket = Bucket.builder()
                .withConfiguration(configuration)
                .build();
        
        cache.put(key, bucket);
        return bucket;
    }

    /**
     * Get or create bucket for rate limiting
     */
    public Bucket resolveBucket(String key, RateLimitTier tier) {
        return cache.computeIfAbsent(key, k -> createNewBucket(k, tier));
    }

    /**
     * Check if request is allowed based on rate limits
     */
    public boolean isRateLimited(String key, RateLimitTier tier) {
        Bucket bucket = resolveBucket(key, tier);
        return bucket.tryConsume(1);
    }

    /**
     * Get remaining tokens in bucket
     */
    public long getRemainingTokens(String key, RateLimitTier tier) {
        Bucket bucket = resolveBucket(key, tier);
        return bucket.getAvailableTokens();
    }

    /**
     * Get reset time for bucket
     */
    public long getResetTime(String key, RateLimitTier tier) {
        Bucket bucket = resolveBucket(key, tier);
        return System.currentTimeMillis() + tier.getRefillDuration().toMillis();
    }

    /**
     * Rate limit key generators for different contexts
     */
    public static class RateLimitKeyGenerator {
        
        /**
         * Generate key for IP-based rate limiting
         */
        public static String ipBasedKey(String ipAddress, String endpoint) {
            return String.format("rate_limit:ip:%s:%s", ipAddress, endpoint);
        }
        
        /**
         * Generate key for user-based rate limiting
         */
        public static String userBasedKey(String userId, String endpoint) {
            return String.format("rate_limit:user:%s:%s", userId, endpoint);
        }
        
        /**
         * Generate key for combined IP and user rate limiting
         */
        public static String combinedKey(String ipAddress, String userId, String endpoint) {
            if (userId != null) {
                return String.format("rate_limit:combined:%s:%s:%s", ipAddress, userId, endpoint);
            }
            return ipBasedKey(ipAddress, endpoint);
        }
        
        /**
         * Generate key for global rate limiting
         */
        public static String globalKey(String endpoint) {
            return String.format("rate_limit:global:%s", endpoint);
        }
    }

    /**
     * Rate limit configuration for specific endpoints
     */
    public static class EndpointRateLimits {
        
        // Public endpoints (no authentication required)
        public static final RateLimitTier LOGIN_ENDPOINT = RateLimitTier.CRITICAL;
        public static final RateLimitTier REGISTER_ENDPOINT = RateLimitTier.CRITICAL;
        public static final RateLimitTier PUBLIC_API = RateLimitTier.PUBLIC;
        
        // Authenticated endpoints
        public static final RateLimitTier AUTHENTICATED_API = RateLimitTier.AUTHENTICATED;
        public static final RateLimitTier PROFILE_ENDPOINT = RateLimitTier.AUTHENTICATED;
        public static final RateLimitTier APPOINTMENT_ENDPOINT = RateLimitTier.AUTHENTICATED;
        
        // Admin endpoints
        public static final RateLimitTier ADMIN_API = RateLimitTier.ADMIN;
        public static final RateLimitTier BULK_OPERATION = RateLimitTier.BULK;
        
        // Emergency endpoints (very restrictive)
        public static final RateLimitTier EMERGENCY_API = RateLimitTier.CRITICAL;
    }
}